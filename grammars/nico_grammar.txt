C  -> DS A | A

DS -> D; | DS D;
D  -> T:LD
LD -> idf | idf , LD
T  -> TU | TL
TU -> int | double | real | char
TL -> int (LD) | double (LD) | real (LD) | char (LD)
LD -> int_lit : int_lit | int_lit : int_lit , LD

A   -> CMD | CMD A
CMD -> LV = E;| LV swap LV; | E; | B
LV  -> idf | idf[LE]
LE  -> E | E, LE
E   -> E+E | E-E | E*E | E/E | (E) | int_lit | f_lit | LV | CP
CP  -> idf(LE)
B   -> if (EB) then A F | while (EB){A}
F   -> end | else A end
EB  -> true | false | (EB) | EB and EB | EB or EB | not EB | E > E | E < E | E le E | E ge E | E eq E | E ne E

code -> declaracoes acoes
	declaracao ';' acoes
	tipo ':' listadeclaracao ';' acoes
	tipolista ':' IDF ';' acoes
	DOUBLE '(' listadupla ')' ':' IDF ';' acoes
	DOUBLE '(' INT_LIT ':' INT_LIT ')' ':' IDF ';' acoes
	double(1:100):a; acoes


terminais:
( ( ( ( ( ( ( ( (
) ) ) ) ) ) ) ) )
; ; ; ; ;
, , ,
: : :
=
[
]
+
-
*
/
{
}
>
<

idf idf
int double real char
f_lit
end 
true
false

idf idf idf
end
int_lit int_lit int_lit int_lit int_lit
swap
if
then
while
else
and
or
not
le
ge
eq
ne

C -> A -> CMD -> E; -> LV; -> idf;
C -> A -> CMD -> E; -> E+E; -> LV+LV -> idf+idf;

IDF+IDF; lvalue: IDF //cria node IDF
lvalue+IDF; lvalue:IDF //cria node IDF
lvalue+lvalue; expr: lvalue //$$ = $1;
expr+lvalue; expr: lvalue //$$ = $1;
expr+expr; expr: expr '+' expr // cria node '+' e node pai
expr; comando: expr ';' // cria node ';' e pai
comando; acoes: comando // $$ = $1
acoes; code: acoes // syntax_tree = $1
code

